# CVE-2019-13272
PTRACE_TRACEME CVE-2019-13272 local privilege escalation vulnerability analysis
-

PTRACE_TRACEME là một lỗ hỏng leo thang đặc quyền trong Kernel Linux được phát hiện bởi Jann Horn tháng 7 năm 2019. Có rất nhiều thứ để nói về việc phát hiện và khai thác lỗ hỏng của tác giả

Phân tích lỗ hỏng:
Ptrace là một system call, nó cung cấp một cách để cho phép một process (tracer) có thể quan sát và điều khiển quá trình thực thi của một process khác (tracee), kiểm tra và thay đổi core image và thanh ghi của nó, chủ yếu được sử dụng để đặt break point trong debug và theo dõi quá trình gọi system call.

``` c
1    396  kernel/ptrace.c <<ptrace_attach>>
             ptrace_link(task, current);
2    469  kernel/ptrace.c <<ptrace_traceme>>
             ptrace_link(current, current->real_parent);
                           
```


Có hai cách để thiết lập một trace relationship:
  - Process sẽ gọi hàm fork và process con của nó sẽ gọi PTRACE_TRACEME (tương ứng hàm ptrace_traceme trong kernel) để khởi tạo tracee.
  - Process gọi PTRACE_ATTACH hoặc pTRACE_SEIZE (tương ứng hàm ptrace_attach trong kernel) để khởi tạo một tracer để trace process khác.
  
Either way, the ptrace_link function will be called at the end to establish the trace relationship between tracer and tracee
Dù sử dùng cách nào ở trên thì hàm ptrace_link vẫn sẽ được gọi cuối cùng để thiết lập trace relationshi giữa tracer và tracee
- Hai tham số truyền vào ptrace_link đối với ptrace_attach là 'task' (tracee) và 'current' (tracer)
- Hai tham số truyền vào ptrace_link đối với ptrace_traceme là 'current' (tracee) và 'current->real_parent' (tracer)

Ở đây, ta cần phải lưu ý hai tham số truyền vào tracer và tracee là gì ở 2 cách trên khi gọi hàm ptrace_link, vì lổ hỏng sẽ nằm ở hàm ptrace_link

``` c
static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
{
        rcu_read_lock();
        __ptrace_link(child, new_parent, __task_cred(new_parent));
        rcu_read_unlock();
}

void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,
                   const struct cred *ptracer_cred)
{
        BUG_ON(!list_empty(&child->ptrace_entry));
        list_add(&child->ptrace_entry, &new_parent->ptraced); // 1. thêm chính nó vào hàng đợi ptraced của process cha
        child->parent = new_parent; // 2. Lưu địa chỉ của process cha trong con trỏ parent
        child->ptracer_cred = get_cred(ptracer_cred); // 3. Lưu ptracer_cred lại, ta cần tập trung vào biến này vì lỗi nằm ở đây
}
```

Mấu chốt để thiết lập trace relationship là tracee sẽ ghi lại cred của tracer và lưu nó trong biến'ptracer_cred 'của tracee. Tên của biến này giống như tên của nó

Khái niệm về ptracer_cred đã được giới thiệu bởi một bản vá vào năm 2016, [ptrace: Capture the ptracer's creds not PT_PTRACE_CAP](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=64b875f7ac8a5d60a4e191479299e931ee949b67). Mục đích của việc giới thiệu ptracer_cred là để thực hiện kiểm tra bảo mật khi tracee thực thi exec để load [setuid executable](https://www.computerhope.com/jargon/s/setuid.htm)

Tại sao chúng ta cần kiểm tra sự an toàn này?

Family của [exec](http://man7.org/linux/man-pages/man3/exec.3.html) có thể cập nhật image của process. Nếu [setuid bit](https://en.wikipedia.org/wiki/Setuid) của file thực thi được set, khi file thực thi được chạy, [euid](https://en.wikipedia.org/wiki/User_identifier) của process sẽ được sửa đổi thành uid của chủ sở hữu file thực thi. Quyền của người dùng cao hơn quyền của process gọi exec và việc chạy loại [setuid executable](https://www.computerhope.com/jargon/s/setuid.htm) này sẽ có tác động leo thang ([escalation](https://www.computerhope.com/jargon/s/setuid.htm)).

Nếu bản thân process thực thi exec là một tracee, sau khi nó thực hiện [setuid executable](https://www.computerhope.com/jargon/s/setuid.htm) privilege escalation, từ đó tracer có thể sửa đổi các thanh ghi và bộ nhớ của tracee bất kỳ lúc nào, tại thời điểm này, tracer có đặc quyền thấp có thể kiểm soát tracee để thực hiện các hoạt động trái phép.

Trong Kernel, dường như không cho phép tồn tại những hành vi vượt quá thẩm quyền như vậy, vì vậy khi thiết lập trace relationships, tracee cần lưu cred của tracer (tức là ptracer_cred), sau đó một exec process, nếu nhận thấy việc thực thi executable setuid bit được set, nó sẽ đánh giá sự cho phép của'ptracer_cred'. Nếu quyền không được thỏa mãn, sự leo thang đặc quyền của bit setuid sẽ không được thực thi, setuid executable sẽ được thực thi với quyền của process ban đầu

Phân tích code của process này như sau (phân tích code của bài viết này dựa trên v4.19-rc8)
``` python
do_execve
  -> __do_execve_file
  -> prepare_binprm 
      -> bprm_fill_uid
      -> security_bprm_set_creds
          ->cap_bprm_set_creds
          -> ptracer_capable
          ->selinux_bprm_set_creds
          ->(apparmor_bprm_set_creds)
          ->(smack_bprm_set_creds)
          ->(tomoyo_bprm_set_creds)

```

Như trên, các hoạt động liên quan đến quyền thực thi chủ yếu nằm trong hàm 'prepare_binprm'
``` c
1567 int prepare_binprm(struct linux_binprm *bprm)
1568 {
1569         int retval;
1570         loff_t pos = 0;
1571 
1572         bprm_fill_uid(bprm); // <-- lắp đầy new process cred
1573 
1574         /* fill in binprm security blob */
1575         retval = security_bprm_set_creds(bprm); // <-- kiểm tra bảo mật, để xem xét sửa đổi crep của new process     
1576         if (retval)
1577                 return retval;
1578         bprm->called_set_creds = 1;
1579 
1580         memset(bprm->buf, 0, BINPRM_BUF_SIZE);
1581         return kernel_read(bprm->file, bprm->buf, BINPRM_BUF_SIZE, &pos);
1582 }
```

Như ở trên, trước tiên gọi 'bprm_fill_uid' để lắp đầy cred của process mới vào lúc đầu, sau đó gọi 'security_bprm_set_creds' để kiểm tra bảo mật và sửa đổi cred mới
``` c
1509 static void bprm_fill_uid(struct linux_binprm *bprm)
1510 {
1511         struct inode *inode;
1512         unsigned int mode;
1513         kuid_t uid;
1514         kgid_t gid;
1515 
1516         /*
1517          * Since this can be called multiple times (via prepare_binprm),
1518          * we must clear any previous work done when setting set[ug]id
1519          * bits from any earlier bprm->file uses (for example when run
1520          * first for a setuid script then again for its interpreter).
1521          */
1522         bprm->cred->euid = current_euid(); // <--- trước tiên sẽ sử dụng euid của process hiện tại
1523         bprm->cred->egid = current_egid();
1524 
1525         if (!mnt_may_suid(bprm->file->f_path.mnt))
1526                 return;
1527 
1528         if (task_no_new_privs(current))
1529                 return;
1530 
1531         inode = bprm->file->f_path.dentry->d_inode;
1532         mode = READ_ONCE(inode->i_mode);
1533         if (!(mode & (S_ISUID|S_ISGID))) // <---------- nếu bit setuid/setgid của file thực thi không được set, hàm sẽ return tại đây.
1534                 return;
1535 
1536         /* Be careful if suid/sgid is set */
1537         inode_lock(inode);
1538 
1539         /* reload atomically mode/uid/gid now that lock held */
1540         mode = inode->i_mode;
1541         uid = inode->i_uid; // <---- nếu S_ISUID được set，sử dụng i_uid của file
1542         gid = inode->i_gid;
1543         inode_unlock(inode);
1544 
1545         /* We ignore suid/sgid if there are no mappings for them in the ns */
1546         if (!kuid_has_mapping(bprm->cred->user_ns, uid) ||
1547                  !kgid_has_mapping(bprm->cred->user_ns, gid))
1548                 return;
1549 
1550         if (mode & S_ISUID) {
1551                 bprm->per_clear |= PER_CLEAR_ON_SETID;
1552                 bprm->cred->euid = uid; // <------ sử dụng uid của file như là euid của new process
1553         }
1554 
1555         if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {
1556                 bprm->per_clear |= PER_CLEAR_ON_SETID;
1557                 bprm->cred->egid = gid;
1558         }
1559 }
```

Nhìn vào 2 dòng code ở trên:
- Dòng 1522, gán ra euid hiện tại của process vào new euid, vì vậy hầu hết các process thực thi đều thực thi dưới quyền ban đầu.
- Dòng 1552, nếu bit suid được set, gán uid của chủ sở hữu file thực thi vào new uid. Có thể hiểu nó giống như việc setuid. New euid trở thành uid của chủ sở hữu file thực thi, nêu chủ sở hữu là một user đặc quyền, leo thang đặc quyền sẽ diễn ra ở đây.

Tuy nhiên, euid ở đây vẫn chưa phải là kết quả cuối cùng và ta cần xem xẻt hàm security_bprm_set_creds để biết thêm về kiểm tra bảo mật.

Hàm security_bprm_set_creds function gọi [LSM](https://en.wikipedia.org/wiki/Linux_Security_Modules) framework

Trên phiên bản kernel mà tôi đã phân tích, có đến 5 điểm hook lsm frameworks thực hiện kiểm tra bảo mật của ‘bprm_set_creds’. Các hàm kiểm tra như sau:
``` python
cap_bprm_set_creds
selinux_bprm_set_creds
apparmor_bprm_set_creds
smack_bprm_set_creds
tomoyo_bprm_set_creds
```

Các hàm phát hiện hook nào sẽ được thực thi ở đây thực sự liên quan đến cấu hình của kernel cụ thể. Về lý thuyết, nếu tất cả các lsm frameworks được bật, tất cả các hàm được đề cập ở trên triển khai phát hiện 'bprm_set_creds' hook sẽ được thực thi

Trong môi trường phân tích của tôi chỉ có duy nhất các hàm phát hiện hook cap_bprm_set_creds và selinux_bprm_set_creds được chạy.

Trong số đó, hàm 'cap_bprm_set_creds' sẽ thay đổi euid
``` c
815 int cap_bprm_set_creds(struct linux_binprm *bprm)
816 {
817         const struct cred *old = current_cred();
818         struct cred *new = bprm->cred;
819         bool effective = false, has_fcap = false, is_setid;
820         int ret;
821         kuid_t root_uid;
===================== skip ======================
838         /* Don't let someone trace a set[ug]id/setpcap binary with the revised
839          * credentials unless they have the appropriate permit.
840          *
841          * In addition, if NO_NEW_PRIVS, then ensure we get no new privs.
842          */
843         is_setid = __is_setuid(new, old) || __is_setgid(new, old);  
844 
845         if ((is_setid || __cap_gained(permitted, new, old)) && // <---- kiểm tra xem việc thực thi setid của chương trình
846             ((bprm->unsafe & ~LSM_UNSAFE_PTRACE) ||
847              !ptracer_capable(current, new->user_ns))) { // <----- Nếu process thực thi execve được trace, và executed program là setuid, quyền sẽ được xem xét thêm vào
848                 /* downgrade; they get no more than they had, and maybe less */
849                 if (!ns_capable(new->user_ns, CAP_SETUID) ||
850                     (bprm->unsafe & LSM_UNSAFE_NO_NEW_PRIVS)) {
851                         new->euid = new->uid; // <----- Nếu việc kiểm tra thất bại, euid của tiến trình mới sẽ được reset về uid ban đầu
852                         new->egid = new->gid;
853                 }
854                 new->cap_permitted = cap_intersect(new->cap_permitted,
855                                                    old->cap_permitted);
856         }
857 
858         new->suid = new->fsuid = new->euid;
859         new->sgid = new->fsgid = new->egid;
===================== skip ======================
    }
```

Như ở trên, 
  - Dòng 845 kiểm tra xem liệu euid có nhất quán với uid gốc hay không (trong phân tích hàm bprm_fill_uid, chúng tôi biết rằng nếu tệp được thực thi có setuid bit được set, euid sẽ không nhất quán) ==> Ở đây tương đương với việc phát hiện process được thực thi có phải là chương trình setid hay không.
  - Dòng 847 sẽ kiểm tra xem process có phải là tracee hay không.
  
Nếu hai điều kiện trên được đáp ứng, hàm ptracer_capable cần được thực thi để kiểm tra quyền. Nếu kiểm tra quyền sai, việc hạ cấp quyền sẽ được thực hiện.
  - Dòng 851, thay đổi giá trị của `new->euid` thành `new->uid`, có nghĩa là quyền được đề cập trong hàm bprm_fill_uid có thể bị hạ cấp ở đây
``` c
    499 bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)
    500 {
    501         int ret = 0;  /* An absent tracer adds no restrictions */
    502         const struct cred *cred;
    503         rcu_read_lock();
    504         cred = rcu_dereference(tsk->ptracer_cred); // <----- lấy ra ptracer_cred  được lưu khi ptrace_link
    505         if (cred)
    506                 ret = security_capable_noaudit(cred, ns, CAP_SYS_PTRACE); // <-------- đi vào lsm framwork để kiểm tra bảo mật
    507         rcu_read_unlock();
    508         return (ret == 0);
    509 }
    
```

Như ở trên
- Dòng 504 lấy ra 'tsk->ptracer_cred'
- Dòng 506, vào lsm framework để kiểm tra 'tsk->ptracer_cred'

Tại thời điểm này, biến 'tsk->ptracer_cred' liên quan đến lỗ hổng này cuối cùng đã xuất hiện. Như đã đề cập trước đó, biến này là cred của tracer được lưu bởi tracee khi  trace relationship được thiết lập.

Khi tracee thực hiện execve sau đó để thực thi chương trình suid executable, nó sẽ gọi hàm ptracer_capable và sử dụng security framework trong lsm để xác định quyền của 'ptracer_cred '

Chúng ta sẽ không phân tích việc kiểm tra capable hook trong lsm framework ở đây. Nói một cách đơn giản, nếu bản thân tracer có đặc quyền root thì việc kiểm tra ở đây sẽ được pass, nếu không, nó sẽ trả về lỗi

Theo phân tích trước đó, nếu phát hiện ptracer_capable không thành công, quyền của new->euid sẽ bị hạ trở lại

Ví dụ: A ptrace B, B thực thi execve '/usr/bin/passwd'. Theo phân tích của đoạn code trên, nếu A có quyền root thì euid của B thực thi passwd là root, ngược lại nó sẽ sử dụng quyền lúc đầu
``` c 
kernel/ptrace.c <<ptrace_traceme>>
             ptrace_link(current, current->real_parent);  

static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
{
        rcu_read_lock();
        __ptrace_link(child, new_parent, __task_cred(new_parent));
        rcu_read_unlock();
}
```

Quay lại đoạn code vulnerable ở trên, tại sao Traceme lại wrong khi ghi cred của cha nó khi thiết lập  trace link? Rõ ràng lúc này cha của nó là tracer?

Chúng tôi sử dụng ví dụ của Jann Horn để minh họa lý do tại sao traceme không thể sử dụng cred của tracer khi thiết lập trace link theo cách này

``` py
 - 1,  task A: fork()s a child, task B
 - 2,  task B: fork()s a child, task C
 - 3,  task B: execve(/some/special/suid/binary)
 - 4,  task C: PTRACE_TRACEME (creates privileged ptrace relationship)
 - 5,  task C: execve(/usr/bin/passwd)
 - 6,  task B: drop privileges (setresuid(getuid(), getuid(), getuid()))
 - 7,  task B: become dumpable again (e.g. execve(/some/other/binary))
 - 8,  task A: PTRACE_ATTACH to task B
 - 9,  task A: use ptrace to take control of task B
 - 10, task B: use ptrace to take control of task C
```

Có tất cả 3 process: A, B, C trong kịch bản trên.
- Trong bước 4, khi task C sử dụng PTRACE_TRACE để thiết lập trace link với B, vì euid của B bây giờ là 0 (vì nó vừa thực thi suid binary), euid của ptracer_cred được ghi bởi C cũng là 0
- Trong bước 5, task C thực thi execve(suid binary) sau đó. Theo phân tích của chúng tôi ở trên, bởi vì ptracer_cred của C là đặc quyền, hàm ptracer_capable được truyền, vì vậy sau khi thực hiện execve, euid của tác vụ C cũng được nâng lên thành 0. Lưu ý rằng trace link của B và C vẫn còn hiệu lực tại thời điểm này.
- Trong bước 6, Task B thực thi setresuid để hạ cấp nó xuống. Mục đích của việc này là để tiến hành attach với task A
- Trong bước 8, Task A sử dụng PTRACE_ATTACH để thiết lập một trace link với B. Cả A và B đều có quyền thông thường, sau đó A có thể kiểm soát B để thực hiện bất cứ hoạt động nào.
- Trong bước 9, Tasb B kiểm soát task C để thực hiện hành động leo thang đặc quyền.

8 bước trước đó đều được thiết lập theo phân tích code trước đó, vậy bước thứ 9 có thể thiết lập được không?

Khi thực hiện bước 9, bản thân task B có đặc quyền thông thường, tác vụ C có đặc quyền gốc và trace link giữa B và C là hợp lệ. Trong điều kiện này, B có thể gửi một yêu cầu ptrace để C thực hiện các hoạt động khác nhau, bao gồm cả việc leo thang đặc quyền không?

Hãy phân tích điều này với code bên dưới:
``` c
1111 SYSCALL_DEFINE4(ptrace, long, request, long, pid, unsigned long, addr,
1112                 unsigned long, data)
1113 {
1114         struct task_struct *child;
1115         long ret;
1116 
1117         if (request == PTRACE_TRACEME) {
1118                 ret = ptrace_traceme(); // <----- đi vào nhánh traceme
1119                 if (!ret)
1120                         arch_ptrace_attach(current);
1121                 goto out;
1122         }
1123 
1124         child = find_get_task_by_vpid(pid);
1125         if (!child) {
1126                 ret = -ESRCH;
1127                 goto out;
1128         }
1129 
1130         if (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {
1131                 ret = ptrace_attach(child, request, addr, data); // <------ đi vào nhánh attach
1132                 /*
1133                  * Some architectures need to do book-keeping after
1134                  * a ptrace attach.
1135                  */
1136                 if (!ret)
1137                         arch_ptrace_attach(child);
1138                 goto out_put_task_struct;
1139         }
1140 
1141         ret = ptrace_check_attach(child, request == PTRACE_KILL ||
1142                                   request == PTRACE_INTERRUPT);
1143         if (ret < 0)
1144                 goto out_put_task_struct;
1145 
1146         ret = arch_ptrace(child, request, addr, data); // <----  các yêu cầu ptrace khác
1147         if (ret || request != PTRACE_DETACH)
1148                 ptrace_unfreeze_traced(child);
1149 
1150  out_put_task_struct:
1151         put_task_struct(child);
1152  out:
1153         return ret;
1154 }
```

Như trên, vì task B và task C đã có các trace links tại thời điểm này rồi, yêu cầu ptrace có thể được gửi trực tiếp đến C thông qua B và hàm Arch_ptrace sẽ được gọi.

``` 
arch/x86/kernel/ptrace.c

arch_ptrace 
    -> ptrace_request 
        -> generic_ptrace_peekdata
           generic_ptrace_pokedata 
            -> ptrace_access_vm 
                -> ptracer_capable 
kernel/ptrace.c
884 int ptrace_request(struct task_struct *child, long request,
885                    unsigned long addr, unsigned long data)
886 {
887         bool seized = child->ptrace & PT_SEIZED;
888         int ret = -EIO;
889         siginfo_t siginfo, *si;
890         void __user *datavp = (void __user *) data;
891         unsigned long __user *datalp = datavp;
892         unsigned long flags;
893 
894         switch (request) {
895         case PTRACE_PEEKTEXT:
896         case PTRACE_PEEKDATA:
897                 return generic_ptrace_peekdata(child, addr, data);
898         case PTRACE_POKETEXT:
899         case PTRACE_POKEDATA:
900                 return generic_ptrace_pokedata(child, addr, data);
901 
=================== skip ================
1105 }



1156 int generic_ptrace_peekdata(struct task_struct *tsk, unsigned long addr,
1157                             unsigned long data)
1158 {
1159         unsigned long tmp;
1160         int copied;
1161 
1162         copied = ptrace_access_vm(tsk, addr, &tmp, sizeof(tmp), FOLL_FORCE); // <--- 调用 ptrace_access_vm
1163         if (copied != sizeof(tmp))
1164                 return -EIO;
1165         return put_user(tmp, (unsigned long __user *)data);
1166 }
1167 
1168 int generic_ptrace_pokedata(struct task_struct *tsk, unsigned long addr,
1169                             unsigned long data)
1170 {
1171         int copied;
1172 
1173         copied = ptrace_access_vm(tsk, addr, &data, sizeof(data), // <---- 调用 ptrace_access_vm
1174                         FOLL_FORCE | FOLL_WRITE);
1175         return (copied == sizeof(data)) ? 0 : -EIO;
1176 }
```
 
Như trên, khi tracer muốn điều khiển tracee thực thi new code logic, nó cần gửi yêu cầu đọc và ghi vào vùng code và vùng nhớ của tracee. Yêu cầu tương ứng là PTRACE_PEEKTEXT/PTRACE_PEEKDATA/PTRACE_POKETEXT/PTRACE_POKEDATA

Các thao tác đọc và ghi này cuối cùng được thực hiện thông qua hàm ptrace_access_vm
``` c
kernel/ptrace.c
38 int ptrace_access_vm(struct task_struct *tsk, unsigned long addr,
39                      void *buf, int len, unsigned int gup_flags)
40 {
41         struct mm_struct *mm;
42         int ret;
43 
44         mm = get_task_mm(tsk);
45         if (!mm)
46                 return 0;
47 
48         if (!tsk->ptrace ||
49             (current != tsk->parent) ||
50             ((get_dumpable(mm) != SUID_DUMP_USER) &&
51              !ptracer_capable(tsk, mm->user_ns))) { // < ----- 又是调用 ptracer_capable 函数
52                 mmput(mm);
53                 return 0;
54         }
55 
56         ret = __access_remote_vm(tsk, mm, addr, buf, len, gup_flags);
57         mmput(mm);
58 
59         return ret;
60 }

kernel/capability.c
499 bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)
500 {
501         int ret = 0;  /* An absent tracer adds no restrictions */
502         const struct cred *cred;
503         rcu_read_lock();
504         cred = rcu_dereference(tsk->ptracer_cred);
505         if (cred)
506                 ret = security_capable_noaudit(cred, ns, CAP_SYS_PTRACE);
507         rcu_read_unlock();
508         return (ret == 0);
509 }
```

Như ở trên, hàm ptrace_access_vm sẽ gọi 'ptracer_capable' mà chúng ta đã phân tích trước đó để xác định xem yêu cầu có thể được thực hiện hay không. Đây là tình huống sử dụng thứ hai của hàm 'ptracer_capable'

Theo kết quả phân tích trước đây của chúng tôi, ptracer_cred được lưu trong task C tại thời điểm này là một cred đặc quyền, vì vậy ptracer_capable sẽ pass tại thời điểm này, có nghĩa là chúng tôi đã trả lời câu hỏi vừa rồi. Trong trường hợp này, tác vụ B với quyền bình thường có thể gửi yêu cầu ptrace để đọc và ghi vào vùng nhớ và vùng code của task C với quyền root.

Lúc này, đặc quyền ptracer_cred được ghi lại bởi task C thực sự đóng hai vai trò
- Bạn có thể cho phép task C thực hiện execve(suid binary) để nâng cao quyền của bạn
- Task B với quyền thông thường có thể thực thi ptrace để đọc và ghi vào vùng code và vùng nhớ của task C, từ đó điều khiển task C thực hiện các hoạt động tùy ý

Sự kết hợp của 2 vai trò trên có phải là một hoạt động leo thang đặc quyền hoàn toàn hay không?

# Tóm tắt
Chúng tôi đã xem xét cẩn thận phân tích code của process ở trên và cuối cùng đã hiểu được đoạn văn được viết trong mô tả bản vá
``` 
PTRACE_TRACEME ghi lại credentials của cha nó như thể cha nó đóng vai trò là subject, nhưng không phải vậy. 
Nếu một process con không đặc quyền độc hại sử dụng PTRACE_TRACEME và cha của nó có đặc quyền, 
sau đó process cha sẽ trở thành attacker-controlled (bởi vì nó giảm đặc quyền và gọi execve()),
kẻ tấn công kết thúc với quyền kiểm soát hai process với ptrace relationship đặc quyền,
ptrace relationship đặc quyền này có thể bị lạm dụng để ptrace suid binary và có được đặc quyền gốc.
```
Về bản chất, lỗ hổng này hơi giống lỗ hổng loại TOCTOU. Việc lấy được ptracer_cred ở giai đoạn traceme và việc sử dụng ptracer_cred ở giai đoạn yêu cầu tiếp theo. Trong yêu cầu ptrace tiếp theo, cred của tracer có thể không phải là lần đầu tiên xác lập trace. Cred tại thời điểm liên kết

``` diff
diff --git a/kernel/ptrace.c b/kernel/ptrace.c
index 8456b6e..705887f 100644
--- a/kernel/ptrace.c
+++ b/kernel/ptrace.c
@@ -79,9 +79,7 @@ void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,
  */
 static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)
 {
-    rcu_read_lock();
-    __ptrace_link(child, new_parent, __task_cred(new_parent));
-    rcu_read_unlock();
+    __ptrace_link(child, new_parent, current_cred());
 }
```

Hãy cùng nhìn lại bản vá của Jann Horn: '__task_cred(new_parent)' ->'current_cred()'

Bản vá có nghĩa là trong trường hợp của PTRACE_TRACEME, ptracer_cred không được sử dụng cred của process cha, mà sử dụng cred của chính nó

Vì vậy, tôi nghĩ rằng từ mục đích của biến này, nó thực sự không ghi lại cred của tracer, mà là cred của 'trace link creater'

Tôi đề nghị Jann Horn thay đổi tên biến này thành ptracelinkcreater_cred. Khi trace link được thiết lập bởi PTRACE_ATTACH, nó bằng với cred của tracer. Khi trace link được thiết lập bởi PTRACE_TRACEME, nó bằng với cred của tracee. Nó thực sự ghi lại trace relationship của người tạo.

# Exploit
Mấu chốt để khai thác lỗ hổng này là tìm một chương trình thực thi phù hợp để bắt đầu task B. Chương trình thực thi này phải đáp ứng các điều kiện sau
- Người dùng bình thường phải có thể gọi được
- Phải có một giai đoạn leo thang đặc quyền để root trong quá trình thực thi
- Sau khi có quyền nâng cấp, quyền hạ cấp phải được thực hiện

(Mục đích của việc tạm thời leo lên root là để cho phép task C có được ptracer_cred của root và mục đích của việc hạ cấp quyền là để cho phép B được đính kèm bởi một quy trình với các đặc quyền ptrace thông thường ))

Ở đây là 3 mẫu code để khai thác:
- [Exploit by Jann Horn](https://bugs.chromium.org/p/project-zero/issues/attachmentText?aid=401217)
- [Exploit by Bcoles](https://github.com/bcoles/kernel-exploits/blob/master/CVE-2019-13272/poc.c)
- [Exploit by Jiayy](https://github.com/jiayy/android_vuln_poc-exp/tree/master/EXP-CVE-2019-13272)

Trong [exploit của Jann Horn](https://bugs.chromium.org/p/project-zero/issues/attachmentText?aid=401217), chương trình [pkexec](http://manpages.ubuntu.com/manpages/trusty/man1/pkexec.1.html) sẵn có trong máy (đối với bản desktop) được sử dụng để bắt đầu task B

[pkexec](http://manpages.ubuntu.com/manpages/trusty/man1/pkexec.1.html) cho phép người dùng có đặc quyền thực thi một chương trình thực thi khác với quyền người dùng khác, được sử dụng trong khung xác thực polkit. Khi sử dụng tham số --user, nó cho phép process nâng cấp quyền lên root và sau đó xuống người dùng được chỉ định, vì vậy nó có thể được sử dụng cho quá trình xây dựng B, ngoài ra, bạn cần tìm các chương trình thực thi được thực thi thông qua khung polkit (Jann Horn sử dụng các helper). Các chương trình helper này cần phải đáp ứng rằng người dùng bình thường có thể thực thichúng bằng pkexec mà không cần phải xác thực (nhiều chương trình được thực thi thông qua polkit yêu cầu xác thực cửa sổ bật lên), cách để thực thi như sau:
``` 
/usr/bin/pkexec —user nonrootuser /user/sbin/some-helper-binary
```

[Exploit](https://github.com/bcoles/kernel-exploits/blob/master/CVE-2019-13272/poc.c) của Bcoles thêm code để tìm thêm helper binary trên cơ sở của Jann Horn. Bởi vì helper của Jann Horn là một chương trình được mã hóa cứng, nó không tồn tại trong nhiều bản phân phối, vì vậy việc khai thác của anh ấy không thể được sử dụng trên nhiều hệ thống phân phối. Ngược lại, code khai thác của bcoles có thể chạy thành công trên nhiều bản phân phối hơn.

Để phục vụ mục đích nghiên cứu, tôi sẽ nói về exploit của Jiayy, bởi vì helper binary của các bản phân phối khác nhau sẽ khác nhau và pkexec chỉ có trên bản phân phối desktop và trên thực tế, lỗ hỏng leo thang đặc quyền này là một lỗ hỏng của Linux kernel, vì vậy, exploit của Jann Horn được thay đổi để sử dụng chương trình fakepkexec để leo thang đặc quyền thông qua 2 chương trình fakepkexec và fakehelper được tạo thủ công (thay vì tìm kiếm từ hệ thống đích), để người đọc có thể chạy exploit này trên bất kỳ hệ thống Linux nào có lỗ hổng này (kể cả không phải déktop) để phục vụ cho việc nghiên cứu.

## exploit analysis

## tham khảo 
[https://www.anquanke.com/post/id/193863#h2-3](https://www.anquanke.com/post/id/193863#h2-3)
